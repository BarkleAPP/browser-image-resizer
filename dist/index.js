function A() { return document.createElement("img") } function W() { return document.createElement("canvas") } function E(e) { let t = atob(e.split(",")[1]), i = e.split(",")[0].split(":")[1].split(";")[0], r = new ArrayBuffer(t.length), o = new Uint8Array(r); for (let n = 0; n < t.length; n++)o[n] = t.charCodeAt(n); return new Blob([r], { type: i }) } function G(e, t) { let i = t.width / t.height, r = Math.min(t.width, e.maxWidth, i * e.maxHeight); return e.maxSize && e.maxSize > 0 && e.maxSize < t.width * t.height / 1e3 && (r = Math.min(r, Math.floor(e.maxSize * 1e3 / t.height))), e.scaleRatio && (r = Math.min(r, Math.floor(e.scaleRatio * t.width))), e.debug && (console.log("browser-image-resizer: original image size = " + t.width + " px (width) X " + t.height + " px (height)"), console.log("browser-image-resizer: scaled image size = " + r + " px (width) X " + Math.floor(r / i) + " px (height)")), r <= 0 && (r = 1, console.warn("browser-image-resizer: image size is too small")), r } function q(e, t) { var n, h, g; let i = document.createElement("canvas"), r = t.outputWidth / e.width; i.width = e.width * r, i.height = e.height * r; let o = (n = e == null ? void 0 : e.getContext("2d")) == null ? void 0 : n.getImageData(0, 0, e.width, e.height), m = (h = i == null ? void 0 : i.getContext("2d")) == null ? void 0 : h.createImageData(i.width, i.height); if (!o || !m) throw Error("Canvas is empty (scaleCanvasWithAlgorithm). You should run this script after th document is ready."); return _(o, m, r), (g = i == null ? void 0 : i.getContext("2d")) == null || g.putImageData(m, 0, 0), i } function F(e) { var i; let t = document.createElement("canvas"); return t.width = e.width / 2, t.height = e.height / 2, (i = t == null ? void 0 : t.getContext("2d")) == null || i.drawImage(e, 0, 0, t.width, t.height), t } function _(e, t, i) { function r(U, T, L, H, I, c) { let S = 1 - I, M = 1 - c; return U * S * M + T * I * M + L * S * c + H * I * c } let o, m, n, h, g, l, x, y, u, d, a, b, w, f, p, z, s, B, R; for (o = 0; o < t.height; ++o)for (n = o / i, h = Math.floor(n), g = Math.ceil(n) > e.height - 1 ? e.height - 1 : Math.ceil(n), m = 0; m < t.width; ++m)l = m / i, x = Math.floor(l), y = Math.ceil(l) > e.width - 1 ? e.width - 1 : Math.ceil(l), u = (m + t.width * o) * 4, d = (x + e.width * h) * 4, a = (y + e.width * h) * 4, b = (x + e.width * g) * 4, w = (y + e.width * g) * 4, f = l - x, p = n - h, z = r(e.data[d], e.data[a], e.data[b], e.data[w], f, p), t.data[u] = z, s = r(e.data[d + 1], e.data[a + 1], e.data[b + 1], e.data[w + 1], f, p), t.data[u + 1] = s, B = r(e.data[d + 2], e.data[a + 2], e.data[b + 2], e.data[w + 2], f, p), t.data[u + 2] = B, R = r(e.data[d + 3], e.data[a + 3], e.data[b + 3], e.data[w + 3], f, p), t.data[u + 3] = R } function O({ img: e, config: t }) { let i = W(); i.width = e.width, i.height = e.height; let r = i == null ? void 0 : i.getContext("2d"); if (!r) throw Error("Canvas is empty (scaleImage). You should run this script after th document is ready."); r.drawImage(e, 0, 0); let o = G(t, i); for (; i.width >= 2 * o;)i = F(i); i.width > o && (i = q(i, Object.assign(t, { outputWidth: o }))); let m = i.toDataURL(t.mimeType, t.quality); return typeof t.onScale == "function" && t.onScale(m), E(m) } var P = { quality: .5, maxWidth: 800, maxHeight: 600, debug: !1, mimeType: "image/jpeg" }; function Q(e, t) { return new Promise((i, r) => { let o = A(), m = new FileReader, n = Object.assign({}, P, t); m.onload = function (h) { if (!h.target || !h.target.result) return r("cannot load image."); o.onerror = function () { r("cannot load image.") }, o.onload = async function () { let g = { img: o, config: n }; try { let l = O(g); i(l) } catch (l) { r(l) } }, o.src = typeof h.target.result == "string" ? h.target.result : URL.createObjectURL(new Blob([h.target.result], { type: e.type })) }; try { m.onerror = function () { r("cannot read image file.") }, m.readAsDataURL(e) } catch (h) { r(h) } }) } export { Q as readAndCompressImage };
